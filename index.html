<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Crusades: Interactive History</title>
    <style>
        /* ================================================================
           MODERN THEME & TYPOGRAPHY
           Clean, professional variables for a polished educational tool.
           ================================================================
        */
        :root {
            --bg-color: #f4f7f6;
            --bg-dot: #e0e5ec;
            
            /* Palette: Deep Crimson, Regal Gold, Slate Blue */
            --primary: #8a1c1c; 
            --accent: #c59d08;
            --secondary: #2c3e50;
            --text-main: #2b2b2b;
            --text-light: #666;
            
            --card-bg: rgba(255, 255, 255, 0.95);
            --card-shadow: 0 4px 20px rgba(0,0,0,0.08);
            --card-border: 1px solid rgba(0,0,0,0.05);
            
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-serif: "Georgia", "Times New Roman", serif; /* Used sparsely for headers */
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            font-family: var(--font-main);
            background-color: var(--bg-color);
            background-image: radial-gradient(var(--bg-dot) 1px, transparent 1px);
            background-size: 20px 20px;
            color: var(--text-main);
            overflow: hidden; /* App handles scrolling */
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* HEADER UI */
        header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: var(--card-bg);
            padding: 15px 25px;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            border: var(--card-border);
            backdrop-filter: blur(10px);
            max-width: 350px;
        }

        h1 {
            margin: 0;
            font-family: var(--font-serif);
            color: var(--primary);
            font-size: 1.5rem;
            letter-spacing: -0.5px;
        }

        p.subtitle {
            margin: 5px 0 0 0;
            font-size: 0.9rem;
            color: var(--text-light);
            line-height: 1.4;
        }

        /* CANVAS AREA */
        #viewport {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
            width: 100%;
            height: 100%;
        }

        #viewport:active { cursor: grabbing; }

        #canvas {
            position: absolute;
            top: 0; left: 0;
            transform-origin: 0 0;
            width: 4000px; /* Large canvas for panning */
            height: 3000px;
        }

        /* SVG CONNECTORS */
        svg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        
        path.connector {
            fill: none;
            stroke: #cbd5e0;
            stroke-width: 2px;
            transition: stroke 0.3s ease;
        }
        
        path.connector.active {
            stroke: var(--primary);
            stroke-width: 3px;
        }

        /* NODES */
        .node {
            position: absolute;
            background: var(--card-bg);
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: var(--card-shadow);
            border: var(--card-border);
            width: 220px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            cursor: pointer;
            z-index: 10;
            border-left: 4px solid var(--secondary);
        }

        .node:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.12);
        }

        /* Node Types Styling */
        .node.root {
            border-left: 6px solid var(--primary);
            width: 260px;
        }
        .node.root h3 { font-size: 1.3rem; color: var(--primary); }

        .node.person {
            border-left: 4px solid var(--accent);
        }
        
        .node.event {
            border-left: 4px solid var(--secondary);
        }

        .node.outcome {
            border-left: 4px solid #27ae60; /* Green for legacy/outcome */
            border-style: solid;
        }

        .node h3 {
            margin: 0 0 6px 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-main);
        }

        .node p {
            margin: 0;
            font-size: 0.85rem;
            color: var(--text-light);
            line-height: 1.4;
        }

        .toggle-icon {
            position: absolute;
            right: 15px;
            top: 15px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #eee;
            color: #666;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: transform 0.3s;
        }
        
        .node.collapsed .toggle-icon { transform: rotate(-90deg); background: var(--primary); color: white; }
        .node.expanded .toggle-icon { background: #eee; }

        /* TOOLTIP / INFO CARD */
        #info-card {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 300px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.05);
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
            transition: all 0.3s ease;
        }

        #info-card.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        #info-card h2 { margin: 0 0 10px 0; font-size: 1.2rem; color: var(--primary); font-family: var(--font-serif); }
        #info-card p { margin: 0; font-size: 0.9rem; color: var(--text-light); line-height: 1.5; }
        #info-card .tag { 
            display: inline-block; 
            background: #f0f0f0; 
            padding: 4px 8px; 
            border-radius: 4px; 
            font-size: 0.75rem; 
            margin-bottom: 10px; 
            color: #555; font-weight: 600; text-transform: uppercase;
        }

        /* TIMELINE STRIP */
        #timeline {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 70px;
            background: white;
            border-top: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.03);
            overflow-x: auto;
        }

        .timeline-track {
            display: flex;
            padding: 0 40px;
            position: relative;
        }
        
        .timeline-point {
            position: relative;
            margin: 0 30px;
            text-align: center;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        
        .timeline-point:hover { opacity: 1; }

        .timeline-point::before {
            content: '';
            display: block;
            width: 10px; height: 10px;
            background: var(--secondary);
            border-radius: 50%;
            margin: 0 auto 8px auto;
        }

        .timeline-point span {
            display: block;
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--text-main);
        }
        
        .timeline-point small {
            font-size: 0.7rem;
            color: var(--text-light);
        }

        /* FOOTER / ABOUT */
        #footer-info {
            position: fixed;
            bottom: 80px;
            left: 20px;
            font-size: 0.75rem;
            color: #999;
            z-index: 100;
        }
        
        /* RESPONSIVE */
        @media (max-width: 768px) {
            header { width: 90%; left: 5%; }
            #info-card { width: 90%; right: 5%; bottom: 80px; }
            .timeline-point { margin: 0 15px; }
        }
    </style>
</head>
<body>

    <header>
        <h1>The Crusades</h1>
        <p class="subtitle">An interactive exploration of the religious wars (1095–1291). Click nodes to expand. Drag to pan.</p>
    </header>

    <div id="viewport">
        <div id="canvas">
            <svg id="svg-layer"></svg>
            <div id="node-layer"></div>
        </div>
    </div>

    <div id="info-card">
        <span class="tag" id="card-tag">Figure</span>
        <h2 id="card-title">Title</h2>
        <p id="card-desc">Description goes here.</p>
    </div>

    <div id="timeline">
        <div class="timeline-track">
            </div>
    </div>

    <div id="footer-info">
        Interactive Educational Resource | Vanilla JS & CSS
    </div>

    <script>
        /**
         * ================================================================
         * DATA STRUCTURE
         * Hierarchical JSON data representing the mind map.
         * ================================================================
         */
        const data = {
            id: "root",
            title: "The Crusades",
            type: "root",
            desc: "A series of religious wars between Christians and Muslims (1095–1291).",
            detail: "Initiated by the Latin Church in the medieval period, aimed at recovering the Holy Land from Islamic rule.",
            children: [
                {
                    id: "causes",
                    title: "Origins & Causes",
                    type: "event",
                    desc: "Religious, political, and economic motivations.",
                    detail: "Key factors included the threat to Byzantium, the Great Schism (1054), and the concept of 'Just War'.",
                    children: [
                        { 
                            id: "urban", 
                            title: "Pope Urban II", 
                            type: "person", 
                            desc: "Council of Clermont (1095)",
                            detail: "Gave the sermon initiating the First Crusade. Famous for the rallying cry 'Deus Vult' (God wills it)."
                        },
                        { 
                            id: "alexios", 
                            title: "Alexios I Komnenos", 
                            type: "person", 
                            desc: "Byzantine Emperor",
                            detail: "Sent a plea to the Pope for military aid against the Seljuk Turks, inadvertently triggering the Crusades."
                        },
                        {
                            id: "motivations",
                            title: "Motivations",
                            type: "event",
                            desc: "Faith, Land, & Penance",
                            detail: "Knights sought remission of sins (plenary indulgence), land in the East, and loot."
                        }
                    ]
                },
                {
                    id: "cr1",
                    title: "First Crusade",
                    type: "event",
                    desc: "1096–1099 (Success)",
                    detail: "The only militarily successful crusade for Christendom. Resulted in the capture of Jerusalem.",
                    children: [
                        { id: "antioch", title: "Siege of Antioch", type: "event", desc: "1097-1098", detail: "A grueling 8-month siege. Crusaders nearly starved but eventually captured the city." },
                        { id: "jerusalem1", title: "Fall of Jerusalem", type: "event", desc: "1099", detail: "Crusaders breached the walls and massacred many Muslim and Jewish inhabitants." },
                        { id: "states", title: "Crusader States", type: "outcome", desc: "Outremer established", detail: "Creation of the Kingdom of Jerusalem, County of Tripoli, Principality of Antioch, and County of Edessa." }
                    ]
                },
                {
                    id: "cr2",
                    title: "Second Crusade",
                    type: "event",
                    desc: "1147–1149 (Failure)",
                    detail: "Sparked by the fall of Edessa. Led by Kings Louis VII and Conrad III, but ended in disaster.",
                    children: [
                        { id: "bernard", title: "Bernard of Clairvaux", type: "person", desc: "Preacher", detail: "Primary spiritual influence who preached the crusade." },
                        { id: "damascus", title: "Siege of Damascus", type: "event", desc: "1148", detail: "A failed siege that destroyed the Crusaders' reputation and led to their retreat." }
                    ]
                },
                {
                    id: "cr3",
                    title: "Third Crusade",
                    type: "event",
                    desc: "1189–1192 (Stalemate)",
                    detail: "Known as the Kings' Crusade. Triggered by Saladin's capture of Jerusalem.",
                    children: [
                        { 
                            id: "saladin", 
                            title: "Saladin", 
                            type: "person", 
                            desc: "Sultan of Egypt/Syria",
                            detail: "Unified Muslim forces. Recaptured Jerusalem in 1187 at the Battle of Hattin. Respected for his chivalry."
                        },
                        { 
                            id: "richard", 
                            title: "Richard I", 
                            type: "person", 
                            desc: "The Lionheart",
                            detail: "King of England. Military genius. Defeated Saladin at Arsuf but could not retake Jerusalem."
                        },
                        { id: "treaty", title: "Treaty of Jaffa", type: "outcome", desc: "1192", detail: "Truce: Jerusalem remained Muslim, but unarmed Christian pilgrims could visit." }
                    ]
                },
                {
                    id: "cr4",
                    title: "Fourth Crusade",
                    type: "event",
                    desc: "1202–1204 (Diverted)",
                    detail: "Never reached the Holy Land. Instead, Crusaders sacked the Christian city of Constantinople.",
                    children: [
                        { id: "venice", title: "Enrico Dandolo", type: "person", desc: "Doge of Venice", detail: "Redirected the crusade to pay off debts owed for the Venetian fleet." },
                        { id: "sack", title: "Sack of Constantinople", type: "event", desc: "1204", detail: "Solidified the Great Schism between Catholic and Orthodox churches. Weakened Byzantium permanently." }
                    ]
                },
                {
                    id: "legacy",
                    title: "Legacy & Impact",
                    type: "outcome",
                    desc: "Long-term Consequences",
                    detail: "Cultural exchange, trade routes, and deep religious scars that persist today.",
                    children: [
                        { id: "eco", title: "Economic", type: "outcome", desc: "Trade Expansion", detail: "Italian city-states (Venice, Genoa) dominated trade. Spices, silk, and sugar entered Europe." },
                        { id: "cult", title: "Cultural", type: "outcome", desc: "Knowledge Transfer", detail: "European re-discovery of Aristotle, algebra, and advanced architecture from the Islamic world." }
                    ]
                }
            ]
        };

        const timelineEvents = [
            { year: "1095", label: "Council of Clermont" },
            { year: "1099", label: "Jerusalem Captured" },
            { year: "1144", label: "Fall of Edessa" },
            { year: "1187", label: "Battle of Hattin" },
            { year: "1192", label: "Treaty of Jaffa" },
            { year: "1204", label: "Sack of Constantinople" },
            { year: "1291", label: "Fall of Acre" }
        ];

        /**
         * ================================================================
         * APP LOGIC
         * Handles rendering, layout calculation, and interactivity.
         * ================================================================
         */
        
        // State
        const state = {
            collapsed: [], // IDs of collapsed nodes
            scale: 1,
            nodes: {},     // Flat map of nodes for easy access
            rootX: 2000,   // Canvas Center X
            rootY: 1500    // Canvas Center Y
        };

        // DOM Elements
        const canvasEl = document.getElementById('canvas');
        const nodeLayer = document.getElementById('node-layer');
        const svgLayer = document.getElementById('svg-layer');
        const infoCard = document.getElementById('info-card');
        const viewport = document.getElementById('viewport');

        // --- 1. INITIALIZATION & HELPERS ---

        function init() {
            renderTimeline();
            // Start centered
            viewport.scrollLeft = state.rootX - viewport.clientWidth / 2;
            viewport.scrollTop = state.rootY - viewport.clientHeight / 2;
            
            // Build Flat Map & Initial Render
            flattenData(data, null);
            renderTree();
        }

        function flattenData(node, parentId) {
            state.nodes[node.id] = { ...node, parent: parentId };
            // Initially collapse deep levels to keep UI clean
            if(node.id.startsWith("cr") || node.id === "legacy") {
                state.collapsed.push(node.id);
            }
            if (node.children) {
                node.children.forEach(child => flattenData(child, node.id));
            }
        }

        // --- 2. LAYOUT ENGINE (Recursive Tree Layout) ---

        function calculateLayout(node, x, y, level, angleRange) {
            // Store calculated position
            const nodeObj = state.nodes[node.id];
            nodeObj._x = x;
            nodeObj._y = y;

            if (!node.children || state.collapsed.includes(node.id)) return;

            const children = node.children;
            const count = children.length;
            
            // Dynamic spacing based on depth
            const radius = 350 - (level * 40); 
            // Spread angle based on number of children
            const totalSpread = Math.min(Math.PI, count * 0.4); 
            const startAngle = -totalSpread / 2;

            children.forEach((child, index) => {
                // Calculate angle for fan layout
                let angleOffset = startAngle + (index / (count - 1 || 1)) * totalSpread;
                if (count === 1) angleOffset = 0;

                // Rotate based on parent's position relative to grandparent (for natural flow)
                // For root, we flow downwards. For others, flow away from center.
                let baseAngle = Math.PI / 2; // Down
                
                if (level > 0) {
                     // Vector from parent to this node (approximated simple logic for demo)
                     // In a real force-directed graph, this is complex.
                     // Here we use a simpler vertical-ish tree logic.
                     const parent = state.nodes[nodeObj.parent];
                     if(parent) {
                        // Keep flowing generally downwards/outwards
                        // X offset helps separate branches
                        const offsetX = (index - (count-1)/2) * 250;
                        const offsetY = 200;
                        
                        calculateLayout(child, x + offsetX, y + offsetY, level + 1);
                        return; 
                     }
                }

                // Root Children Layout (Radial-ish)
                const finalAngle = baseAngle + angleOffset;
                // Specific manual overrides for better aesthetics on First level
                let dx, dy;
                if(level === 0) {
                    // Manually spreading the main branches
                    const spreadX = 400; 
                    const spreadY = 300;
                    if(index === 0) { dx = -spreadX; dy = spreadY; } // Causes
                    if(index === 1) { dx = -spreadX/2; dy = spreadY + 150; } // CR1
                    if(index === 2) { dx = spreadX/2; dy = spreadY + 150; } // CR2
                    if(index === 3) { dx = spreadX; dy = spreadY; } // CR3
                    if(index === 4) { dx = spreadX + 200; dy = spreadY - 100; } // CR4
                    if(index === 5) { dx = -spreadX - 200; dy = spreadY - 100; } // Legacy
                } else {
                    // Fallback
                    dx = Math.sin(finalAngle) * radius;
                    dy = Math.cos(finalAngle) * radius;
                }
                
                calculateLayout(child, x + dx, y + dy, level + 1);
            });
        }
        
        // Simpler layout: Horizontal/Vertical mix
        function computeTreePositions(nodeId, x, y, depth) {
            const node = state.nodes[nodeId];
            node._x = x;
            node._y = y;
            
            const rawNode = findNodeData(nodeId, data);
            if(!rawNode.children || state.collapsed.includes(nodeId)) return;

            const children = rawNode.children;
            const widthPerNode = 260; // Node width + gap
            const totalWidth = children.length * widthPerNode;
            let startX = x - (totalWidth / 2) + (widthPerNode / 2);
            
            children.forEach((child, i) => {
                // Stagger Y slightly to avoid straight lines looking boring
                const stagger = (i % 2 === 0) ? 0 : 40;
                computeTreePositions(child.id, startX + (i * widthPerNode), y + 250 + stagger, depth + 1);
            });
        }

        function findNodeData(id, current) {
            if (current.id === id) return current;
            if (current.children) {
                for (let child of current.children) {
                    const found = findNodeData(id, child);
                    if (found) return found;
                }
            }
            return null;
        }

        // --- 3. RENDERING ---

        function renderTree() {
            // 1. Calculate Positions
            computeTreePositions("root", state.rootX, state.rootY, 0);

            // 2. Clear DOM
            nodeLayer.innerHTML = '';
            svgLayer.innerHTML = '';

            // 3. Draw Nodes & Lines recursively
            drawNodeAndChildren("root");
        }

        function drawNodeAndChildren(nodeId) {
            const node = state.nodes[nodeId];
            const rawNode = findNodeData(nodeId, data);

            // Create HTML Node
            const el = document.createElement('div');
            el.className = `node ${rawNode.type} ${state.collapsed.includes(nodeId) ? 'collapsed' : 'expanded'}`;
            el.style.left = node._x + 'px';
            el.style.top = node._y + 'px';
            
            // Icon
            const icon = rawNode.children ? '<div class="toggle-icon">></div>' : '';

            el.innerHTML = `
                ${icon}
                <h3>${rawNode.title}</h3>
                <p>${rawNode.desc}</p>
            `;

            // Interaction
            el.onclick = (e) => {
                e.stopPropagation();
                if(rawNode.children) {
                    toggleNode(nodeId);
                } else {
                    showInfo(rawNode);
                }
            };

            el.onmouseenter = () => {
                showInfo(rawNode);
                highlightPath(nodeId, true);
            };
            
            el.onmouseleave = () => {
                highlightPath(nodeId, false);
            };

            nodeLayer.appendChild(el);

            // Draw Connection to Parent
            if (node.parent) {
                const pNode = state.nodes[node.parent];
                drawCurve(pNode._x + 110, pNode._y + 80, node._x + 110, node._y, nodeId);
            }

            // Recurse
            if (rawNode.children && !state.collapsed.includes(nodeId)) {
                rawNode.children.forEach(child => drawNodeAndChildren(child.id));
            }
        }

        function drawCurve(x1, y1, x2, y2, id) {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            
            // Bezier curve logic for smooth tree
            const cp1x = x1;
            const cp1y = y1 + (y2 - y1) / 2;
            const cp2x = x2;
            const cp2y = y2 - (y2 - y1) / 2;
            
            const d = `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
            
            path.setAttribute("d", d);
            path.setAttribute("class", "connector");
            path.setAttribute("id", `path-${id}`);
            svgLayer.appendChild(path);
        }

        // --- 4. INTERACTIVITY ---

        function toggleNode(id) {
            const idx = state.collapsed.indexOf(id);
            if (idx > -1) {
                state.collapsed.splice(idx, 1); // Expand
            } else {
                state.collapsed.push(id); // Collapse
            }
            renderTree();
        }

        function showInfo(nodeData) {
            infoCard.querySelector('#card-tag').innerText = nodeData.type.toUpperCase();
            infoCard.querySelector('#card-tag').style.color = 'var(--text-light)';
            infoCard.querySelector('#card-title').innerText = nodeData.title;
            infoCard.querySelector('#card-desc').innerText = nodeData.detail || nodeData.desc;
            infoCard.classList.add('visible');
        }
        
        // Hide info card when clicking bg
        document.addEventListener('click', (e) => {
             if(e.target.closest('.node') || e.target.closest('#info-card')) return;
             infoCard.classList.remove('visible');
        });

        function highlightPath(nodeId, active) {
            const path = document.getElementById(`path-${nodeId}`);
            if(path) {
                if(active) path.classList.add('active');
                else path.classList.remove('active');
            }
            // Optional: Recursively highlight up the tree
            if(active && state.nodes[nodeId].parent) {
                highlightPath(state.nodes[nodeId].parent, true);
            } else if (!active && state.nodes[nodeId].parent) {
                highlightPath(state.nodes[nodeId].parent, false);
            }
        }

        function renderTimeline() {
            const track = document.querySelector('.timeline-track');
            timelineEvents.forEach(evt => {
                const el = document.createElement('div');
                el.className = 'timeline-point';
                el.innerHTML = `<span>${evt.year}</span><small>${evt.label}</small>`;
                track.appendChild(el);
            });
        }

        // --- 5. PANNING LOGIC ---
        let isPanning = false;
        let startX, startY, scrollLeft, scrollTop;

        viewport.addEventListener('mousedown', (e) => {
            isPanning = true;
            viewport.style.cursor = 'grabbing';
            startX = e.pageX - viewport.offsetLeft;
            startY = e.pageY - viewport.offsetTop;
            scrollLeft = viewport.scrollLeft;
            scrollTop = viewport.scrollTop;
        });

        viewport.addEventListener('mouseleave', () => { isPanning = false; viewport.style.cursor = 'grab'; });
        viewport.addEventListener('mouseup', () => { isPanning = false; viewport.style.cursor = 'grab'; });

        viewport.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            e.preventDefault();
            const x = e.pageX - viewport.offsetLeft;
            const y = e.pageY - viewport.offsetTop;
            const walkX = (x - startX) * 1; 
            const walkY = (y - startY) * 1;
            viewport.scrollLeft = scrollLeft - walkX;
            viewport.scrollTop = scrollTop - walkY;
        });

        // Run
        init();

    </script>
</body>
</html>
